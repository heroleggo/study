# Segment Tree

### 어떤 이유로 등장하게 되었을까?

시간을 줄이기 위해서.

사실, 여러 가지 자료구조의 출현은 오래 걸리는 것이 싫어서가 아닐까?

개념이 어렵다고 하더라도, 컴퓨터에서 실행이 가능하고 이전보다 빠르다면 사용하지 않을 이유가 없다.

### 어떤 상황에서 사용하는가?

부분합을 구해야 할 때 주로 사용

수열이 있고, 그 수열에서 특정 구간의 합을 계산하는 방법은 크게 2가지가 존재한다고 생각 (인덱스 0부터 시작한다고 가정)

1. i ~ j 까지 하나하나 더해서 저장하기
2. 각 인덱스까지의 합을 모두 구해둔 상태에서 0 ~ j 까지의 합에서 0 ~ i 까지의 합 빼기

속도 자체는 비슷하지만, 수열의 값이 변경되는 상황에서는 부분합의 모든 값을 변경해야 함
-> 부분합을 어떻게 저장하고 사용하느냐에 따라 속도가 천차만별

-> 세그먼트 트리를 사용할 경우, 값 변경과 부분합 연산을 모두 O(logN)으로 수행할 수 있음

### Segment Tree 개념

1. Binary Tree (좌우로 나눠서 서칭)
2. Leaf 노드에 수열의 데이터 저장
3. Parent 노드에 자식들의 합 저장
4. Height는 h = ceil(logN), 필요 배열의 크기는 2^(h + 1) - 1


### 사용 방법

Tree initialize 과정에서, start와 end를 넣어줌 -> start, end 정보를 가지고 재귀적으로 합 연산을 수행하며 데이터 삽입, leaf일 경우 값 바로 집어넣기

init이 되면, 각 노드에 부분합이나 수열의 값이 들어감

합을 찾을 경우, 루트에서 노드 담당구간 [start, end]와 원하는 [left, right] 를 기준으로 값 탐색 진행

case 1. start, end와 left, right가 아예 겹치지 않는 경우

- 탐색 안함, 0 반환

case 2. left, right 안에 start, end가 있는 경우

- 노드의 담당 구간이 left, right에 모두 포함되기 때문에 합에 해당하는 노드의 값을 반환

case 3. start, end 안에 left, right가 있는 경우

- left, right, start, end를 조정하여 재귀적 재탐색 진행

case 4. left, right와 start, end 사이 겹친 구간이 존재하는 경우 (case 1 ~ 3을 제외한 모든 것이 해당함)

- left, right, start, end를 조정하여 재귀적 재탐색 진행

case 3, 4의 경우 아래와 같이 재탐색을 진행해야 함

```
case 3 예시

노드의 담당 구간이 0 ~ 9, 검색을 1 ~ 4까지

-> 0 ~ 9 안에 1 ~ 4 포함

(0 ~ 4 안에 1 ~ 4 검색 결과) + (5 ~ 9 안에 1 ~ 4 검색 결과)
```

```
case 4 예시

노드의 담당 구간이 5 ~ 9, 검색을 3 ~ 6까지

-> 5 ~ 9와 3 ~ 6이 겹침 (5 ~ 6)

-> (5 ~ 7 안에 3 ~ 6 검색 결과) + (8 ~ 9 안에 3 ~ 6 검색 결과)

-> 5 ~ 6 안에 3 ~ 6 검색 결과 + 7 안에 3 ~ 6 검색 결과 + 8 ~ 9 안에 3 ~ 6 검색 결과

-> 5 ~ 6 값 반환 + 0 반환 + 0 반환
```

### Segment Tree의 값 변경

DFS로 node의 담당 구간 안에 변경하는 값이 존재할 경우 변경해주면 됨